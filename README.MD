# ðŸ bee-threads

[![npm version](https://img.shields.io/npm/v/bee-threads.svg)](https://www.npmjs.com/package/bee-threads)
[![npm downloads](https://img.shields.io/npm/dm/bee-threads.svg)](https://www.npmjs.com/package/bee-threads)
[![license](https://img.shields.io/npm/l/bee-threads.svg)](https://github.com/samsantosb/BeeThreads/blob/main/LICENSE)

> Run sync code in worker threads with a simple await.

```js
const { beeThreads } = require('bee-threads');

const hash = await beeThreads
  .run((pwd) => require('crypto').pbkdf2Sync(pwd, 'salt', 100000, 64, 'sha512').toString('hex'))
  .usingParams('password')
  .execute();
```

**Short syntax:**

```js
const { bee } = require('bee-threads');

const hash = await bee(
  (pwd) => require('crypto').pbkdf2Sync(pwd, 'salt', 100000, 64, 'sha512').toString('hex')
)('password');
```

## Install

```bash
npm install bee-threads
```

---

## `bee` â€” Short Syntax

```js
// no params (always requires empty call)
await bee(() => 42)()

// params together
await bee((a, b, c) => a + b + c)(1, 2, 3)

// curry style
await bee((a, b, c) => a + b + c)(1)(2)(3)

// with external variables
const TAX = 0.2;
await bee((price) => price * (1 + TAX))(100)({ beeClosures: { TAX } })
```

---

## `beeThreads` â€” Full API

```js
await beeThreads.run(fn).execute()
await beeThreads.run(fn).usingParams(args).execute()
await beeThreads.run(fn).usingParams(args).setContext({ VAR }).execute()
```

### Methods

| Method | Description |
|--------|-------------|
| `.usingParams(...args)` | Pass arguments |
| `.setContext(obj)` | Inject external variables |
| `.signal(AbortSignal)` | Cancellation |
| `.transfer([ArrayBuffer])` | Zero-copy transfer |
| `.retry({ attempts })` | Auto-retry |
| `.priority('high'\|'low')` | Queue priority |
| `.execute()` | Run |

### Variants

| Method | Description |
|--------|-------------|
| `beeThreads.run(fn)` | Normal execution |
| `beeThreads.safeRun(fn)` | Never throws â€” returns `{ status, value/error }` like `Promise.allSettled` |
| `beeThreads.withTimeout(ms)(fn)` | Execution with timeout |
| `beeThreads.stream(generatorFn)` | Async iterator from generator |

---

## Pool

```js
beeThreads.configure({ poolSize: 8, minThreads: 2 });
await beeThreads.warmup(4);   // pre-create workers
await beeThreads.shutdown();  // terminate all
beeThreads.getPoolStats();    // metrics
```

---

## Errors

```js
const { TimeoutError, AbortError, QueueFullError, WorkerError } = require('bee-threads');
```

---

## Use Cases

1. **Password Hashing** â€” PBKDF2, bcrypt, scrypt
2. **Image Processing** â€” resize, compress, filters (sharp, jimp)
3. **Large JSON Parsing** â€” 50MB+ JSON files
4. **Data Compression** â€” gzip, brotli, zstd
5. **Complex Regex** â€” pattern matching on large text
6. **PDF Generation** â€” multi-page documents
7. **Batch Validation** â€” validate thousands of records

---

## Why bee-threads?

**Developer Experience:**

- **Inline functions** â€” no separate worker files
- **Simple syntax** â€” `await bee(fn)(args)` 
- **Closure support** â€” pass external variables with `beeClosures`
- **Full TypeScript** â€” complete type definitions
- **Zero config** â€” works out of the box

**Performance:**

- **Worker pool** â€” reuses threads, no cold-start
- **Load balancing** â€” distributes tasks across workers
- **Priority queue** â€” critical tasks first
- **Auto-retry** â€” handles transient failures

**Production Ready:**

- **Non-blocking shutdown** â€” `worker.unref()` doesn't hold process
- **Console forwarding** â€” logs from workers appear in main thread
- **Graceful degradation** â€” queue overflow handling

## License

MIT
